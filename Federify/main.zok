import "./u32_array_to_field_array" as u32_array_to_field
import "./u32_array_to_u64_array" as u32_array_to_u64
import "hashes/keccak/256bit" as keccak


def mean<D, N>(u32[N][D] a, u32 feature, u32 dataPoints ) -> u32:
    u32 res = 0
    for u32 i in 0..N do
        res = if i >= dataPoints then res else res + a[i][feature] fi 
    endfor
    return (res / dataPoints)

def var<D, N>(u32[N][D] a, u32 mu, u32  accuracy, u32 feature, u32 dataPoints) -> u32:
    u32 res = 0
    u32 r = 0
    for u32 i in 0..N do
        r = if a[i][feature] > mu then a[i][feature] - mu else mu - a[i][feature] fi 
        r = if i >= dataPoints then 0 else r fi 
        res = res + (r*r)
    endfor
    return (res/ dataPoints)

def model_check<D, N>( u32[N][D] data, u32[D] mu, u32[D] sigma, u32 accuracy, u32 dataPoints ) -> bool:
    bool out = true
    u32 calculated = 0
    for u32 i in 0..D do
        calculated = mean(data, i, dataPoints)
        out = out && (mu[i] <= calculated + (accuracy/100)  && mu[i] >= calculated - (accuracy/100))
        calculated = var(data, mu[i], accuracy, i, dataPoints)
        out = out && (sigma[i] <= calculated + (accuracy/100)* (accuracy/100)) && (sigma[i] >= calculated - (accuracy/100)* (accuracy/100))
    endfor
    return out

def computation_check <D, N, F>(u64[4] random_value, u64[4] hash_value, u32[N][D]input_data, u64[F]flattened_format) -> u64[4]:
/////// Note: F should be dividable by D  
    assert(F% D == 0)
    u32 G = F/D
    u32 last_group = N % G
    u32 R =  if last_group == 0 then N/G else (N/G) + 1 fi 
    u32 index = 0
    u64[D] formated_data = u32_array_to_u64(input_data[0])
    bool is_correct = false
    u64[4] data_hash = keccak([0])
    for u32 round in 0..R do 
        index = round * G
        G = if round == (R-1) && last_group!= 0 then last_group else G fi 
        for u32 group in 0..G do 
            formated_data = u32_array_to_u64(input_data[index + group])
            for u32 feature in 0..D do 
                flattened_format[(group * D) + feature] = formated_data[feature]
            endfor 
        endfor 
        data_hash = if round == R-1 && last_group!= 0 then keccak(flattened_format[0.. (last_group * D)]) else keccak(flattened_format) fi
        hash_value = keccak::<12>([random_value[0], random_value[1], random_value[2], random_value[3], hash_value[0], hash_value[1], hash_value[2], hash_value[3], data_hash[0], data_hash[1], data_hash[2], data_hash[3]])
    endfor
    return hash_value


def main(private u32[100][5] data, private u32[5] mu, private u32[5] sigma, private u32 dataPoints, u32 accuracy, u32 number_of_points_in_class, u32 class, private field random, private u64[4] random_value, private u64[4] initial_random, u64[4] hash_input, private u64[25] flattened_format) -> bool :
    bool out = true
    field[5] mu_in_field = u32_array_to_field(mu)
    field[5] sigma_in_field = u32_array_to_field(sigma)
    u64[4] computed_hash = computation_check(random_value, initial_random, data, flattened_format) 
    out = out && model_check::<5,100>(data, mu, sigma, accuracy, dataPoints)
    out = out && (computed_hash[0] == hash_input[0] && computed_hash[1] == hash_input[1] && computed_hash[2] == hash_input[2] && computed_hash[3] == hash_input[3])
    return out